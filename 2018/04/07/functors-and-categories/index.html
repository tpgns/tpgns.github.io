<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="mido&#39;s IT blog github page">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Functors와 카테고리 - mido
        
    </title>

    <link rel="canonical" href="midojeong.github.io/2018/04/07/functors-and-categories/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116376595-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-116376595-1');
    </script>

</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('bg.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#자바스크립트" title="자바스크립트">자바스크립트</a>
                            
                              <a class="tag" href="/tags/#함수형" title="함수형">함수형</a>
                            
                        </div>
                        <h1>Functors와 카테고리</h1>
                        <h2 class="subheading">함수형 자료구조</h2>
                        <span class="meta">
                            Posted by mido on
                            2018-04-07
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">mido</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>이 글은  <a href="https://medium.com/@_ericelliott?source=post_header_lockup" target="_blank" rel="noopener">Eric Elliott</a> 이 <strong>medium</strong>에서 연재하는 Composing Software 시리즈를 번역한 것입니다.  <a href="https://medium.com/javascript-scene/functors-categories-61e031bac53f" target="_blank" rel="noopener">[원문보기]</a></p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*uVpU7iruzXafhU2VLeH4lw.jpeg" alt=""></p>
<p><em>Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</em></p>
<blockquote>
<p>참고 : 이 글은 JavaScript ES6+의 함수형 프로그래밍 및 소프트웨어 합성 방법론을 기초부터 다루는 &quot;소프트웨어 합성&quot;시리즈의 일부 입니다.  앞으로 계속하여 연재될 것입니다.<br>
<a href="https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30" target="_blank" rel="noopener">&lt;이전</a>  |  <a href="https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea" target="_blank" rel="noopener">&lt;&lt; Part 1에서 다시 시작</a>  |  <a href="https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d" target="_blank" rel="noopener">다음&gt;</a></p>
</blockquote>
<p><strong>Functor는</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 사용자가 맵핑 할 수있는 <strong>데이터 타입</strong>입니다.  내부의 값에 함수를 적용하는 인터페이스가 있는 <strong>컨테이너</strong>입니다.  functor를 발견하면  <em>“mappable”</em> 한 무언가라고 생각하면 됩니다. functor 타입은 일반적으로 객체처럼 구현되며 구조를 유지한채 입력에서 출력으로 맵핑하는  <code>.map()</code>  메소드를 가집니다.  이 때 &quot;구조 유지&quot;란 동일한 유형의 functor를 리턴한다는 것을 의미합니다 (컨테이너 내부의 값은 다른 유형 일 수 있음).</p>
<p>functor는 무언가를 담을 수 있는 상자<sup>box</sup>와 맵핑<sup>mapping</sup> 인터페이스를 제공합니다.  배열<sup>Array</sup>은 functor의 좋은 예이며 promise, 스트림, 트리 등 다양한 종류의 객체 또한 <em>“mappable”</em> 한 것들입니다. JavaScript에 내장 된 배열 및 promise 객체는 functor처럼 작동합니다. 콜렉션(배열, 스트림 등)은 일반적으로  <code>.map()</code>을 사용해서 원소들을 순회하며 주어진 함수를 각 값에 적용하지만 모든 functor가 콜렉션처럼 순회하지는 않습니다. 사실 functor란 특정 문맥<sup>context</sup>에서 함수를 적용하는 것에 관한 개념입니다.</p>
<p>Promise는  <code>.map()</code>  대신  <code>.then()</code>을 사용합니다.  일반적으로  <code>.then()</code>을 비동기식  <code>.map()</code>메서드로 생각할 수 있습니다. 단, 중첩된 promise가 있는 경우는 예외이며, 자동으로 외부 promise를 처리하지 않습니다.  다시 말하자면 promise가 아닌 값에 대해서  <code>.then()</code>은 비동기 <code>.map()</code>과 같은 역할을 합니다. 반면에 promise값의 경우  <code>.then()</code>은 모나드의 <code>.chain()</code> 메서드(<code>.bind()</code>  또는  <code>.flatMap()</code>이라고도 함)처럼 동작합니다.   따라서 promise은 functor가 아니고 모나드도 아닙니다. 그러나 실제로는 그 둘 중 하나로 취급 할 수 있습니다. 모나드가 무엇인지 몰라도 걱정하지 마십시오. 모나드는 일종의 functor이며, 우리는 먼저 functor에 대해 알아볼 것입니다.</p>
<p>다양한 것들을 functor로 만들어주는 라이브러리들이 있습니다.</p>
<p>Haskell에서 functor 타입은 다음과 같이 정의됩니다.</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fmap</span> :: (a -&gt;</span> <span class="function"><span class="title">b</span>) -&gt;</span> <span class="function"><span class="title">fa</span> -&gt;</span> fb</span><br></pre></td></tr></table></figure>
<p>a를 받아 b를 리턴하는 함수를 인자로 받습니다. 그리고 a가 담긴 functor를 받아 b가 담긴 functor를 리턴합니다.  <code>fa</code>  와  <code>fb</code>는  “a의 functor”,  &quot;b의 functor&quot;로 읽을 수 있습니다. 즉,  <code>fa</code>에는 <code>a</code>가 담긴 상자가 있고  <code>fb</code>에는 <code>b</code>가 담긴 상자가 있습니다.</p>
<p>functor를 사용하는 것은 간단합니다.  <code>map()</code>을 호출하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   </span><br><span class="line">f.map(double);  <span class="comment">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<h2 id="functors-law">Functor’s Law</h2>
<p>카테고리<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 에는 두 가지 중요한 속성이 있습니다.</p>
<ol>
<li>항등<sup>identity</sup></li>
<li>합성<sup>composition</sup></li>
</ol>
<p>functor는 카테고리들 사이의 맵핑이기 때문에, functor는 항등과 합성을 지원해야 합니다. 이 두가지는 functor의 법칙으로 알려져 있습니다.</p>
<h3 id="항등identity">항등Identity</h3>
<p>임의의 functor <code>f</code>에 항등함수(<code>x =&gt; x</code>)를 맵핑시키면 동일한 <code>f</code>가 리턴되어야 합니다:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   </span><br><span class="line">f.map(<span class="function"><span class="params">x</span> =&gt;</span> x);  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="합성composition">합성Composition</h3>
<p>functor는 합성이 가능해야 합니다.  <code>F.map(x =&gt; f(g(x)))</code>  는  <code>F.map(g).map(f)</code>  와 동일합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Functor.<span class="built_in">map</span>( f . g ) === Functor.<span class="built_in">map</span>(g).<span class="built_in">map</span>(f)</span><br></pre></td></tr></table></figure>
<p>함수 합성이란 어떤 함수의 출력을 다른 함수에 넣는 것입니다. 예를 들어,  인수로 <code>x</code>를 가지는 함수 <code>f</code>와 <code>g</code>가 합성된 <code>(f ∘ g)(x)</code>는 <code>f(g(x))</code>를 의미합니다.</p>
<p>함수형 프로그래밍에 나오는 용어는 대부분 범주론<sup>category</sup> <sup>theory</sup>에서 왔습니다. 범주론의 핵심은 합성입니다.  범주론이 처음에는 무서워보일 수 있지만 알고보면 쉽습니다. 다이빙 보드에서 뛰어 내리거나 롤러 코스터를 타는 것과 같습니다.  다음은 범주론의 몇 가지 중요한 핵심과 이론적 기초입니다.</p>
<ul>
<li>카테고리는 객체와 객체들간의 화살표의 모음입니다. ( &quot;객체&quot;은 문자 그대로 객체<sup>object</sup> 입니다)<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li>
<li>화살표는 사상<sup>morphism</sup>입니다<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>. 사상은 코드에서 함수로 구현됩니다.</li>
<li>객체들이 <code>a -&gt; b -&gt; c</code>처럼 연결됐을 때  합성을 통해 <code>a -&gt; c</code>로 직접 맵핑시킬 수 있어야 합니다.</li>
<li>모든 화살표는 컴포지션으로 나타낼 수 있습니다 (단지 객체 자신을 가리키는 항등 화살표일지라도).  카테고리의 모든 객체에는 항등 화살표가 있습니다.</li>
</ul>
<p><code>a</code>를 취하여  <code>b</code> 를 리턴하는 함수  <code>g</code>  가 있고  <code>b</code>를 취하여  <code>c</code>리턴하는 또 다른 함수  <code>f</code>가 있을 때  <code>f</code>  와  <code>g</code>의 합성을 나타내는 함수  <code>h</code>도 있어야합니다.  그러므로  <code>a -&gt; c</code>는  <code>f ∘ g</code>라는 합성 (<code>f</code>  <em>after</em>  <code>g</code>)이며 <code>h(x) = f(g(x))</code>와 같습니다.  함수는 왼쪽에서 오른쪽으로 합성되지 않고 오른쪽에서 왼쪽으로 되기 때문에  <code>f ∘ g</code>  는 종종  <code>f</code>  <em>after</em>  <code>g</code>라고 읽습니다.</p>
<p>합성은 <strong>결합법칙</strong><sup>associative</sup> <sup>law</sup>이 적용됩니다.  간단하게 말하자면 함수를 합성할 때 기본적으로 괄호가 필요 없다는 뜻 입니다.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h∘<span class="comment">(g∘f)</span> = <span class="comment">(h∘g)</span>∘f = h∘g∘f</span><br></pre></td></tr></table></figure>
<p>JavaScript 코드로 합성을 다시 한 번 살펴 보겠습니다.</p>
<p><code>F</code>라는 functor가 있을 때:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> F = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>다음 두 줄의 코드는 같은 표현입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F.map(<span class="function"><span class="params">x</span> =&gt;</span> f(g(x)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// is equivalent to...</span></span><br><span class="line"></span><br><span class="line">F.map(g).map(f);</span><br></pre></td></tr></table></figure>
<h2 id="endofunctors5">Endofunctors<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></h2>
<p>endofunctor는 카테고리에서 다시 같은 카테고리로 맵핑되는 functor입니다.</p>
<p>Functor는 카테고리에서 카테고리로 맵핑 할 수 있습니다.  <code>X -&gt; Y</code></p>
<p>endofunctor는 동일한 카테고리로 맵핑합니다.  <code>X -&gt; X</code></p>
<p>모나드는 endofunctor입니다.  기억나십니까<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>:</p>
<blockquote>
<p><em>“모나드는 endofunctor라는 카테고리에 속한 한 monoid에 불과해. 뭐가 문제야?”</em><br>
<em>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</em></p>
</blockquote>
<p>그 말이 조금 더 이해되었기를 바랍니다. monoid와 monads에 대해선 나중에 알아볼 것입니다.</p>
<h2 id="functor-구현하기">Functor 구현하기</h2>
<p>여기 간단한 functor가 하나 있습니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Identity = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;  <span class="attr">map</span>: <span class="function"><span class="params">fn</span> =&gt;</span> Identity(fn(value))&#125;);</span><br></pre></td></tr></table></figure>
<p>아래 코드를 보면 <code>Identity</code>가 functor 법칙을 만족시키는걸 알 수 있습니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace() is a utility to let you easily inspect  </span></span><br><span class="line"><span class="comment">// the contents.  </span></span><br><span class="line"><span class="keyword">const</span> trace = <span class="function"><span class="params">x</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(x);  </span><br><span class="line">  <span class="keyword">return</span> x;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> u = Identity(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identity law  </span></span><br><span class="line">u.map(trace);             <span class="comment">// 2  </span></span><br><span class="line">u.map(<span class="function"><span class="params">x</span> =&gt;</span> x).map(trace); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Composition law  </span></span><br><span class="line"><span class="keyword">const</span> r1 = u.map(<span class="function"><span class="params">x</span> =&gt;</span> f(g(x)));  </span><br><span class="line"><span class="keyword">const</span> r2 = u.map(g).map(f);</span><br><span class="line"></span><br><span class="line">r1.map(trace); <span class="comment">// 5  </span></span><br><span class="line">r2.map(trace); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>이제 배열을 맵핑하는 것처럼 어떤 데이터 타입이라도 맵핑 할 수 있습니다. 좋군요!</p>
<p>이는 JavaScript로 구현한 <strong>가장</strong> 단순한 functor입니다. 그러나 JavaScript의 데이터 타입들이 지원하는 몇 가지 기능이 빠져 있습니다. 그것들을 추가합시다.  <code>+</code>  연산자가 숫자와 문자열 값을 둘 다 처리 할 수 ​​있다면 멋지지 않겠습니까?</p>
<p>따라서 우리가해야 할 일은  <code>.valueOf()</code>  구현하는 것이며  <code>.valueOf()</code>는 또한 functor에서 값을 푸는<sup>unwrap</sup> 편리한 방법처럼 보입니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Identity = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;  </span><br><span class="line">  map: <span class="function"><span class="params">fn</span> =&gt;</span> Identity(fn(value)),</span><br><span class="line"></span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> value,  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints = (Identity(<span class="number">2</span>) + Identity(<span class="number">4</span>));  </span><br><span class="line">trace(ints); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hi = (Identity(<span class="string">'h'</span>) + Identity(<span class="string">'i'</span>));  </span><br><span class="line">trace(hi); <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>valueOf 메소드는 식이 평가될 때 자동으로 호출됩니다. -역자</em></p>
</blockquote>
<p>좋습니다.  그러나 콘솔에서  <code>Identity</code> 인스턴스를 검사하려면 어떻게해야할까요? <code>&gt; &quot;Identity(value)&quot;</code>이라고 프린트되면 멋질 것입니다.  <code>.toString()</code>  메소드를 추가해봅시다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`Identity(<span class="subst">$&#123;value&#125;</span>)`</span>,</span><br></pre></td></tr></table></figure>
<p>괜찮네요. 이제 JS의 표준 순회 프로토콜을 구현하겠습니다.  커스텀 반복자를 추가하면됩니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">yield</span> value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 다음과 같은 작업을 수행 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [Symbol.iterator] enables standard JS iterations:  </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">6</span>, <span class="number">7</span>, ...Identity(<span class="number">8</span>)];  </span><br><span class="line">trace(arr); <span class="comment">// [6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p>만약 <code>Identity(n)</code>을 받아  <code>n + 1</code>  ,  <code>n + 2</code>등을 포함하는 <code>Identity</code> 배열을 리턴하려면 어떻게 해야 합니까? 참 쉽죠 ?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fRange = (  </span><br><span class="line">  start,  </span><br><span class="line">  end  </span><br><span class="line">) =&gt; <span class="built_in">Array</span>.from(  </span><br><span class="line">  &#123; <span class="attr">length</span>: end - start + <span class="number">1</span> &#125;,  </span><br><span class="line">  (x, i) =&gt; Identity(i + start)  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>Array.from은 첫번째 인자로 유사배열( length속성이 있는 객체)를 받고 두번째 인자(옵션)로 생성시 맵핑할 함수를 받습니다. -역자</em></p>
</blockquote>
<p>자 이제, 만약 <code>fRange</code>가 임의의 functor에 대해 기능하게 하고싶습니다.  데이터 타입의 각 인스턴스가 생성자<code>constructor</code>에 대한 참조를 가져야 한다는 스펙이 있다면 어떨까요?  바꿔봅시다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fRange = (  </span><br><span class="line">  start,  </span><br><span class="line">  end  </span><br><span class="line">) =&gt; <span class="built_in">Array</span>.from(  </span><br><span class="line">  &#123; <span class="attr">length</span>: end - start + <span class="number">1</span> &#125;,  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// change `Identity` to `start.constructor`  </span></span><br><span class="line">  (x, i) =&gt; start.constructor(i + start)  </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> range = fRange(Identity(<span class="number">2</span>), <span class="number">4</span>);  </span><br><span class="line">range.map(<span class="function"><span class="params">x</span> =&gt;</span> x.map(trace)); <span class="comment">// 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<p>값이 functor인지 테스트 하려면 어떻게해야할까요?  이를 위해  <code>Identity</code>에 <code>is(x)</code>라는 정적 메소드와 <code>.toString()</code> 정적 메소드를 하나 추가해줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Identity, &#123;  </span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Identity'</span>,  </span><br><span class="line">  is: <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">typeof</span> x.map === <span class="string">'function'</span>  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = Identity(<span class="number">5</span>);</span><br><span class="line">Identity.is(a) <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>
<p>이 모든 것들을 하나로 합쳐보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Identity = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;  </span><br><span class="line">  map: <span class="function"><span class="params">fn</span> =&gt;</span> Identity(fn(value)),  </span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> value,  </span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`Identity(<span class="subst">$&#123;value&#125;</span>)`</span>,  </span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">yield</span> value;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="keyword">constructor</span>: Identity  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.assign(Identity, &#123;  </span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Identity'</span>,  </span><br><span class="line">  is: <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">typeof</span> x.map === <span class="string">'function'</span>  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>functor 나 endofunctor에 속하기 위해 위 코드들이 전부 필요하지는 않습니다. 편의성을 위해 추가한 것들일 뿐입니다.  functor가 되기 위해서는 functor법칙 두가지를 충족 시키는 <code>.map()</code> 인터페이스만 있으면 됩니다.</p>
<h2 id="왜-functors를-사용할까요">왜 Functors를 사용할까요?</h2>
<p>Functor를 사용하는데는 여러 이유가 있습니다. 무엇보다 중요한 것은 다양한 데이터 유형에 대해 작동하는 공통 인터페이스를 구현하는 것입니다.  예를 들어, functor내의 값이  <code>undefined</code>거나  <code>null</code>이 아닌 경우에만 연산이 되게 하려면 어떡해야 할까요?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the predicate  </span></span><br><span class="line"><span class="keyword">const</span> exists = <span class="function"><span class="params">x</span> =&gt;</span> (x.valueOf() !== <span class="literal">undefined</span> </span><br><span class="line">                  &amp;&amp; x.valueOf() !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ifExists = <span class="function"><span class="params">x</span> =&gt;</span> (&#123;  </span><br><span class="line">  map: <span class="function"><span class="params">fn</span> =&gt;</span> exists(x) ? x.map(fn) : x  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add1 = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nothing happens...  </span></span><br><span class="line">ifExists(Identity(<span class="literal">undefined</span>)).map(trace);  </span><br><span class="line"><span class="comment">// Still nothing...  </span></span><br><span class="line">ifExists(Identity(<span class="literal">null</span>)).map(trace);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 42  </span></span><br><span class="line">ifExists(Identity(<span class="number">20</span>))  </span><br><span class="line">  .map(add1)  </span><br><span class="line">  .map(double)  </span><br><span class="line">  .map(trace)  </span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>마지막으로 함수형 프로그래밍의 주요 관심사는 작은 함수들을 조합하여 높은 수준으로 추상화된 코드를 작성하는 것입니다.  따라서 어떤 functor에서도 작동하는 <em>generic</em> <code>map</code>을 만들어 보겠습니다. <code>fn</code> 함수를 인수로 부분적용해서 functor를 받는 새 함수를 리턴하게 하면 됩니다.</p>
<p>쉽습니다. 좋아하는 <code>auto-curry</code>라이브러리를 가져오거나 이전에 사용했던 마법을 쓰면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = (  </span><br><span class="line">  f, arr = []  </span><br><span class="line">) =&gt; <span class="function">(<span class="params">...args</span>) =&gt;</span> (  </span><br><span class="line">  a =&gt; a.length === f.length ?  </span><br><span class="line">    f(...a) :  </span><br><span class="line">    curry(f, a)  </span><br><span class="line">)([...arr, ...args]);</span><br></pre></td></tr></table></figure>
<p>이제 <code>map</code>을 우리가 원하는데로 다룰 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = curry(<span class="function">(<span class="params">fn, F</span>) =&gt;</span> F.map(fn));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mdouble = map(double);   </span><br><span class="line">mdouble(Identity(<span class="number">4</span>)).map(trace); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3 id="결론">결론</h3>
<p>Functor는 우리가 맵핑할 수 있는 것들 입니다. 형식적으로 말하자면, functor는 카테고리에서 카테고리로의 맵핑입니다.  어떤 functor는 카테고리에서 다시 같은 카테고리로 맵핑 될 수 있습니다. (<em>endofunctor</em>)</p>
<p>카테고리는 객체의 집합이며 객체를 연결하는 화살표가 있습니다.  화살표는 morphisms(혹은 함수 또는 조합<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>)을 뜻합니다. 카테고리의 각 객체는 항등 morphism(<code>x =&gt; x</code>)을 가집니다.  <code>A -&gt; B -&gt; C</code>로 객체가 사상될 경우,  <code>A -&gt; C</code>로의 연결이 있어야합니다.</p>
<p>functor는 모든 데이터 유형에서 작동하는 다양한 공용 함수를 만들 수있는 훌륭한 고차원 추상화입니다.</p>
<p><a href="#"><strong>다음: 함수형 믹스인 &gt;</strong></a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>펑터라고 발음합니다. 함수자 혹은 함자로 번역이 되는데 그보다는 단어를 그대로 사용하기로 결정했습니다 - 역자 <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p>수학의 범주론에 나오는 개념입니다. 이에 대해 <a href="https://www.amazon.com/s/ref=dp_byline_sr_book_1?ie=UTF8&amp;text=Eugenia+Cheng&amp;search-alias=books&amp;field-author=Eugenia+Cheng&amp;sort=relevancerank" target="_blank" rel="noopener">Eugenia Cheng</a>의 How To Bake PI라는 비교적 쉽게 쓰인 입문서가 있습니다. -역자 <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p>이때 객체란 어떤 실행 프로세스 내부의 추상화된 인스턴스가 아니라 사물, 어떤 것이라고 이해하면 됩니다. -역자 <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4" class="footnote-item"><p>맵핑과 동일합니다. -역자 <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5" class="footnote-item"><p>functor에 붙은 접두사 endo-는 &quot;inside, within, internal,&quot;라는 뜻을 가지고 있습니다. 즉, 닫힌계라고 생각하시면 됩니다. 엔도펑터라고 발음합니다. -역자 <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
<li id="fn6" class="footnote-item"><p>전 글 <a href="https://midojeong.github.io/2018/03/24/why-learn-functional-programming-in-javascript/">왜 자바스크립트로 함수형 프로그래밍을 배우는가</a>에 나옵니다 <a href="#fnref6" class="footnote-backref">↩</a></p>
</li>
<li id="fn7" class="footnote-item"><p>composition을 여기서는 조합이라 번역했습니다 <a href="#fnref7" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/04/07/functional-mixins/" data-toggle="tooltip" data-placement="top" title="함수형 믹스인">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/03/31/reduce/" data-toggle="tooltip" data-placement="top" title="Reduce">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#functors-law"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Functor’s Law</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#항등identity"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">항등Identity</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#합성composition"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">합성Composition</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#endofunctors5"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Endofunctors[5]</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#functor-구현하기"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Functor 구현하기</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#왜-functors를-사용할까요"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">왜 Functors를 사용할까요?</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#결론"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">결론</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#자바스크립트" title="자바스크립트">자바스크립트</a>
                        
                          <a class="tag" href="/tags/#함수형" title="함수형">함수형</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>



<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "midojeong";
    var disqus_identifier = "midojeong.github.io/2018/04/07/functors-and-categories/";
    var disqus_url = "midojeong.github.io/2018/04/07/functors-and-categories/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/midojeong">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; mido 2018 
                    <br>
                    Powered by <a href="https://hexo.io/">Hexo</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("midojeong.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-116376595-1';
    var _gaDomain = 'https://midojeong.github.io';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
